<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Doblo Crash ‚Äì Volant Fluide</title>
  <style>
    :root {
      --bg-start: #0c1a24;
      --bg-end: #1f3a52;
      --card-bg: rgba(13, 24, 33, 0.72);
      --button-replay: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
      --button-pause: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
      --button-text: #fdfdfd;
      --text-main: #f7f9fb;
      --white-van: #ffffff;
      --red-stripe: #ff4757;
      --gray-car: #cbd5e1;
      --wheel-bg: #2c3e50;
      --wheel-line: #34495e;
      font-family: "Segoe UI", Tahoma, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: linear-gradient(135deg, var(--bg-start) 0%, var(--bg-end) 100%);
      color: var(--text-main);
      overflow: hidden;
      touch-action: manipulation;
    }

    .card {
      width: min(94vw, 540px);
      padding: clamp(18px, 4.5vw, 28px);
      border-radius: 28px;
      background: var(--card-bg);
      backdrop-filter: blur(12px);
      box-shadow: 0 28px 48px rgba(0, 0, 0, 0.42);
      display: grid;
      gap: clamp(14px, 3.5vw, 20px);
      animation: fadeIn 0.6s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    header {
      display: grid; gap: 4px; text-align: center;
    }
    header h1 { 
      margin: 0; 
      font-size: clamp(24px, 5.5vw, 32px); 
      letter-spacing: 1px; 
      background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    header p { 
      margin: 0; 
      opacity: .8; 
      font-size: clamp(14px, 3.6vw, 16px); 
    }

    .hud {
      display: flex; align-items: center; justify-content: space-between;
      font-weight: 700; letter-spacing: .5px; font-size: clamp(14px, 3.8vw, 16px);
    }

    .hud .pill {
      padding: 8px 12px; 
      border-radius: 999px; 
      background: rgba(255,255,255,.08);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
      transition: transform 0.2s ease;
    }

    .hud .pill:hover {
      transform: scale(1.05);
    }

    .canvas-wrap {
      position: relative; 
      border-radius: 20px; 
      overflow: hidden;
      background: linear-gradient(to bottom, #0b1720, #1a2a3a);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.04), 0 8px 32px rgba(0,0,0,0.3);
      width: 100%;
      aspect-ratio: 400 / 640;
      min-height: 360px;
    }

    canvas { 
      width: 100%; 
      height: 100%; 
      display: block; 
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    .overlay {
      position: absolute; inset: 0;
      display: grid; place-items: center; text-align: center;
      padding: 20px; 
      background: rgba(11,23,32,0.8);
      opacity: 0; 
      pointer-events: none; 
      transition: opacity 300ms ease;
      backdrop-filter: blur(4px);
    }

    .overlay.show { 
      opacity: 1; 
      pointer-events: auto; 
    }

    .overlay .box {
      background: rgba(13, 24, 33, 0.9);
      border-radius: 20px; 
      padding: clamp(24px, 6vw, 32px);
      box-shadow: 0 18px 36px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.08);
      max-width: 90%;
      animation: popIn 0.4s ease-out;
    }

    @keyframes popIn {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .overlay h2 {
      margin: 0 0 12px; 
      font-size: clamp(24px, 7vw, 40px);
      letter-spacing: 1px;
      color: #ff6b6b;
    }
    .overlay p { 
      margin: 0 0 20px; 
      opacity: .9; 
      font-size: 16px;
    }

    .row {
      display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;
    }

    button.btn {
      appearance: none; 
      border: 0; 
      cursor: pointer; 
      color: var(--button-text);
      background: var(--button-replay); 
      font-weight: 800; 
      letter-spacing: .8px;
      padding: 14px 20px; 
      border-radius: 16px; 
      box-shadow: 0 12px 26px rgba(238, 90, 82, 0.4);
      transition: all 200ms ease; 
      font-size: 16px;
      position: relative;
      overflow: hidden;
    }

    button.btn::before {
      content: '';
      position: absolute;
      top: 0; left: -100%;
      width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    button.btn:hover { 
      transform: translateY(-2px); 
      box-shadow: 0 18px 36px rgba(238, 90, 82, 0.5); 
    }

    button.btn:hover::before {
      left: 100%;
    }

    button.btn:active { 
      transform: translateY(0); 
    }

    .controls {
      display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 8px;
    }

    /* Volant */
    .steering-container {
      position: relative;
      width: 80px;
      height: 80px;
      cursor: grab;
    }

    .steering-wheel {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: var(--wheel-bg);
      box-shadow: inset 0 0 0 2px var(--wheel-line), 0 4px 12px rgba(0,0,0,0.3);
      position: relative;
      transition: transform 0.1s ease-out;
      touch-action: none;
      user-select: none;
    }

    .steering-wheel:active {
      cursor: grabbing;
    }

    .steering-wheel::before,
    .steering-wheel::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 4px;
      height: 20px;
      background: var(--wheel-line);
      transform-origin: bottom center;
    }

    .steering-wheel::before {
      transform: translate(-50%, -50%) rotate(0deg);
    }

    .steering-wheel::after {
      transform: translate(-50%, -50%) rotate(90deg);
    }

    .steering-center {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      background: #ecf0f1;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: inset 0 0 0 2px var(--wheel-line);
    }

    footer { 
      text-align: center; 
      opacity: .7; 
      font-size: 13px; 
      font-style: italic;
      margin-top: 10px;
    }

    @media (max-width: 480px) {
      .steering-container { width: 70px; height: 70px; }
    }
  </style>
</head>
<body>
  <main class="card">
    <header>
      <h1>Doblo Crash</h1>
      <p>Conduis ton Doblo blanc et rouge avec le volant ! √âvite les voitures en douceur. üéÆ</p>
    </header>

    <div class="hud">
      <div class="pill">Score : <span id="score">0</span></div>
      <div class="pill">Meilleur : <span id="best">0</span></div>
      <div class="pill"><button id="pauseBtn" class="cbtn" style="padding:8px 12px; font-size:14px">‚è∏Ô∏è Pause</button></div>
    </div>

    <div class="canvas-wrap">
      <canvas id="game" width="400" height="640" aria-label="Jeu Doblo Crash"></canvas>

      <div id="overlay" class="overlay" aria-live="polite">
        <div class="box">
          <h2>F√©licitations ! üéâ</h2>
          <p>Crash √©pique ! Ton score : <strong id="finalScore">0</strong><br>Reprends le volant pour une prochaine manche !</p>
          <div class="row">
            <button class="btn" id="retryBtn">Rejouer üöó</button>
          </div>
        </div>
      </div>
    </div>

    <div class="controls">
      <div class="steering-container" id="steering">
        <div class="steering-wheel" id="wheel"></div>
        <div class="steering-center"></div>
      </div>
    </div>

    <footer>
      Tourne le volant pour diriger ! Fl√®ches ‚Üë‚Üì pour vitesse, P pour pause. Mobile : glisse sur le volant.
    </footer>
  </main>

  <script>
    (function(){
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      // Responsive canvas
      function fitCanvas(){
        let rect = canvas.getBoundingClientRect();
        if (rect.height < 2) {
          const pr = canvas.parentNode.getBoundingClientRect();
          if (pr.width > 0 && pr.height > 0) rect = pr;
        }
        const w = Math.max(1, Math.round(rect.width * DPR));
        const h = Math.max(1, Math.round(rect.height * DPR));
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
        }
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      }
      new ResizeObserver(fitCanvas).observe(canvas);
      window.addEventListener('resize', () => fitCanvas());
      window.addEventListener('load', fitCanvas);
      setTimeout(fitCanvas, 0);

      // Param√®tres
      const LANES = 3;
      let laneW, leftEdge, roadW, roadBottom;

      const settings = {
        baseEnemySpeed: 1.8,
        maxEnemyOnScreen: 3,
        spawnEveryMs: 1800,
        accelFactor: 0.00006,
        enemySpeedCap: 4.5,
        steeringSensitivity: 0.005, // Sensibilit√© du volant
        maxSteerAngle: Math.PI / 2, // Angle max
        damping: 0.95, // Amortissement pour retour au centre
      };

      const state = {
        running: true,
        gameOver: false,
        time: 0,
        lastSpawn: 0,
        enemySpeed: settings.baseEnemySpeed,
        score: 0,
        best: parseInt(localStorage.getItem('doblo-crash-best') || '0', 10),
        steerAngle: 0, // Angle du volant
      };

      const ui = {
        score: document.getElementById('score'),
        best: document.getElementById('best'),
        overlay: document.getElementById('overlay'),
        retry: document.getElementById('retryBtn'),
        pause: document.getElementById('pauseBtn'),
        finalScore: document.getElementById('finalScore'),
        wheel: document.getElementById('wheel'),
        steering: document.getElementById('steering'),
      };
      ui.best.textContent = state.best;

      const player = { 
        w: 46, h: 80, x: 0, y: 0, vx: 0, vy: 0 
      };
      const enemies = [];

      // Volant events
      let isDragging = false;
      let startAngle = 0;
      let currentAngle = 0;

      function handleStart(e) {
        isDragging = true;
        const rect = ui.steering.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        let clientX = e.clientX || (e.touches && e.touches[0].clientX);
        let clientY = e.clientY || (e.touches && e.touches[0].clientY);
        startAngle = Math.atan2(clientY - centerY, clientX - centerX);
        currentAngle = 0;
        ui.wheel.style.transition = 'none';
      }

      function handleMove(e) {
        if (!isDragging) return;
        e.preventDefault();
        const rect = ui.steering.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        let clientX = e.clientX || (e.touches && e.touches[0].clientX);
        let clientY = e.clientY || (e.touches && e.touches[0].clientY);
        const moveAngle = Math.atan2(clientY - centerY, clientX - centerX);
        let deltaAngle = moveAngle - startAngle;
        if (deltaAngle > Math.PI) deltaAngle -= 2 * Math.PI;
        if (deltaAngle < -Math.PI) deltaAngle += 2 * Math.PI;
        currentAngle = Math.max(-settings.maxSteerAngle, Math.min(settings.maxSteerAngle, currentAngle + deltaAngle));
        startAngle = moveAngle;
        ui.wheel.style.transform = `rotate(${currentAngle}rad)`;
        state.steerAngle = currentAngle;
      }

      function handleEnd(e) {
        if (!isDragging) return;
        isDragging = false;
        ui.wheel.style.transition = 'transform 0.3s ease-out';
        // Retour progressif au centre
        const returnInterval = setInterval(() => {
          currentAngle *= settings.damping;
          ui.wheel.style.transform = `rotate(${currentAngle}rad)`;
          state.steerAngle = currentAngle;
          if (Math.abs(currentAngle) < 0.01) {
            clearInterval(returnInterval);
            currentAngle = 0;
            state.steerAngle = 0;
          }
        }, 16);
      }

      ui.steering.addEventListener('mousedown', handleStart);
      ui.steering.addEventListener('mousemove', handleMove);
      ui.steering.addEventListener('mouseup', handleEnd);
      ui.steering.addEventListener('mouseleave', handleEnd);

      // Touch support
      ui.steering.addEventListener('touchstart', handleStart, { passive: false });
      ui.steering.addEventListener('touchmove', handleMove, { passive: false });
      ui.steering.addEventListener('touchend', handleEnd);

      // Clavier fallback
      const keys = {};
      window.addEventListener('keydown', (e) => {
        keys[e.key] = true;
        if (state.gameOver && e.key === ' ') { e.preventDefault(); restart(); return; }
        if (e.key === 'ArrowUp') state.enemySpeed = Math.min(settings.enemySpeedCap, state.enemySpeed * 1.008);
        if (e.key === 'ArrowDown') state.enemySpeed = Math.max(settings.baseEnemySpeed, state.enemySpeed * 0.995);
        if (e.key.toLowerCase() === 'p') { e.preventDefault(); togglePause(); }
      });
      window.addEventListener('keyup', (e) => { keys[e.key] = false; });

      ui.retry.addEventListener('click', restart);
      ui.pause.addEventListener('click', togglePause);
      window.addEventListener('blur', () => { if (state.running) togglePause(true); });

      function togglePause(forceOn = false){
        if (forceOn) {
          state.running = false;
          ui.pause.textContent = '‚ñ∂Ô∏è Reprendre';
          return;
        }
        state.running = !state.running;
        ui.pause.textContent = state.running ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Reprendre';
        if (state.running) lastFrame = performance.now();
      }

      function restart(){
        state.gameOver = false;
        ui.overlay.classList.remove('show');
        enemies.length = 0;
        state.time = 0;
        state.lastSpawn = 0;
        state.enemySpeed = settings.baseEnemySpeed;
        state.score = 0;
        state.steerAngle = 0;
        currentAngle = 0;
        ui.wheel.style.transform = 'rotate(0rad)';
        player.x = (canvas.width / DPR / 2) - player.w / 2;
        player.vx = 0;
        state.running = true;
        lastFrame = performance.now();
        ui.score.textContent = '0';
      }

      function layout(){
        const W = canvas.width / DPR, H = canvas.height / DPR;
        roadW = Math.min(340, Math.max(260, W * 0.78));
        laneW = roadW / LANES;
        leftEdge = (W - roadW) / 2;
        roadBottom = H;

        player.y = H - 120;
        player.w = laneW * 0.65;
        player.h = Math.max(75, laneW * 1.15);
        if (player.x === 0) player.x = W / 2 - player.w / 2;
      }

      function trySpawn(dt){
        if (enemies.length >= settings.maxEnemyOnScreen) return;
        state.lastSpawn += dt;
        if (state.lastSpawn >= settings.spawnEveryMs / (1 + state.score / 10000)) {
          state.lastSpawn = 0;
          const lane = Math.floor(Math.random() * LANES);
          const e = createEnemy(lane);
          enemies.push(e);
        }
      }

      function createEnemy(lane){
        const W = canvas.width / DPR;
        const w = laneW * 0.68;
        const h = Math.max(65, laneW * 1.05);
        const xCenter = leftEdge + laneW * (lane + 0.5);
        return { 
          lane, 
          x: xCenter - w/2, 
          y: -h - 30, 
          w, 
          h, 
          speed: state.enemySpeed * (0.9 + Math.random() * 0.15),
          color: `hsl(${Math.random() * 60 + 200}, 50%, 70%)`
        };
      }

      function update(dt){
        state.enemySpeed = Math.min(settings.enemySpeedCap, state.enemySpeed + settings.accelFactor * dt);
        state.score += dt * 0.012;
        ui.score.textContent = Math.floor(state.score).toString();

        // Mouvement fluide du joueur bas√© sur le volant
        const steerForce = state.steerAngle * settings.steeringSensitivity * roadW;
        player.vx += steerForce * (dt / 16);
        player.vx *= 0.92; // Friction
        player.x += player.vx * (dt / 16);
        // Limites route
        player.x = Math.max(leftEdge + 10, Math.min(player.x, leftEdge + roadW - player.w - 10));

        // Update ennemis
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          e.y += e.speed * (dt / 16.6667);
          if (e.y > roadBottom + 50) {
            enemies.splice(i, 1);
          }
        }

        // Collisions
        for (const e of enemies) {
          if (rectsOverlap(player, e)) {
            gameOver();
            return;
          }
        }
      }

      function rectsOverlap(a, b) {
        const margin = 6;
        return !(
          a.x + a.w < b.x + margin ||
          a.x > b.x + b.w - margin ||
          a.y + a.h < b.y + margin ||
          a.y > b.y + b.h - margin
        );
      }

      function draw(){
        const W = canvas.width / DPR, H = canvas.height / DPR;
        ctx.clearRect(0, 0, W, H);

        drawRoad(ctx, W, H, state.time);

        enemies.forEach(e => drawEnemyCar(ctx, e));

        drawPlayerVan(ctx, player);
      }

      function drawRoad(ctx, W, H, time) {
        const gradient = ctx.createLinearGradient(0, 0, 0, H);
        gradient.addColorStop(0, '#1a2a3a');
        gradient.addColorStop(1, '#0f222f');
        ctx.fillStyle = gradient;
        ctx.fillRect(leftEdge, 0, roadW, H);

        ctx.fillStyle = 'rgba(255,255,255,.15)';
        ctx.fillRect(leftEdge - 2, 0, 4, H);
        ctx.fillRect(leftEdge + roadW - 2, 0, 4, H);

        ctx.strokeStyle = 'rgba(255,255,255,.25)';
        ctx.lineWidth = 5;
        ctx.setLineDash([20, 20]);
        ctx.lineDashOffset = -(time / 100) % 40;
        for (let i = 1; i < LANES; i++) {
          const x = leftEdge + laneW * i;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, H);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      function drawEnemyCar(ctx, car) {
        const { x, y, w, h, color } = car;
        const r = 8;

        ctx.fillStyle = color;
        roundRect(ctx, x, y, w, h, r, true);

        ctx.fillStyle = 'rgba(0,0,0,.3)';
        roundRect(ctx, x + w * 0.15, y + h * 0.1, w * 0.7, h * 0.3, 6, true);

        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fillRect(x + 4, y + h * 0.7, 6, 4);
        ctx.fillRect(x + w - 10, y + h * 0.7, 6, 4);

        ctx.fillStyle = 'rgba(0,0,0,.2)';
        ctx.fillRect(x + 3, y + h - 3, w - 6, 3);
      }

      function drawPlayerVan(ctx, van) {
        const { x, y, w, h } = van;
        const r = 12;

        ctx.fillStyle = 'var(--white-van)';
        roundRect(ctx, x, y, w, h, r, true);

        ctx.fillStyle = 'var(--red-stripe)';
        // Rayure diagonale sup√©rieure
        ctx.beginPath();
        ctx.moveTo(x + w * 0.1, y + h * 0.2);
        ctx.lineTo(x + w * 0.9, y + h * 0.2);
        ctx.lineTo(x + w * 0.8, y + h * 0.4);
        ctx.lineTo(x + w * 0.2, y + h * 0.4);
        ctx.closePath();
        ctx.fill();

        // Rayure droite
        ctx.beginPath();
        ctx.moveTo(x + w * 0.7, y);
        ctx.lineTo(x + w, y + h * 0.3);
        ctx.lineTo(x + w, y + h * 0.7);
        ctx.lineTo(x + w * 0.7, y + h);
        ctx.closePath();
        ctx.fill();

        // Rayure gauche
        ctx.beginPath();
        ctx.moveTo(x, y + h * 0.3);
        ctx.lineTo(x, y + h * 0.7);
        ctx.lineTo(x + w * 0.3, y + h);
        ctx.lineTo(x + w * 0.3, y + h * 0.7);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = 'rgba(0,0,0,.25)';
        roundRect(ctx, x + w * 0.2, y + h * 0.15, w * 0.6, h * 0.25, 8, true);

        // Gyrophare
        ctx.fillStyle = '#00bfff';
        roundRect(ctx, x + w / 2 - 8, y - 10, 16, 8, 4, true);

        // Phares
        ctx.fillStyle = 'rgba(255,255,200,0.9)';
        ctx.fillRect(x + 5, y + h * 0.75, 8, 5);
        ctx.fillRect(x + w - 13, y + h * 0.75, 8, 5);

        // Roues
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(x + w * 0.2, y + h - 8, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + w * 0.8, y + h - 8, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = 'rgba(0,0,0,.25)';
        ctx.fillRect(x + 4, y + h - 2, w - 8, 4);
      }

      function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
        if (typeof radius === 'number') {
          radius = {tl: radius, tr: radius, br: radius, bl: radius};
        } else {
          radius = {...{tl:0, tr:0, br:0, bl:0}, ...radius};
        }
        ctx.beginPath();
        ctx.moveTo(x + radius.tl, y);
        ctx.lineTo(x + width - radius.tr, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
        ctx.lineTo(x + width, y + height - radius.br);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
        ctx.lineTo(x + radius.bl, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
        ctx.lineTo(x, y + radius.tl);
        ctx.quadraticCurveTo(x, y, x + radius.tl, y);
        ctx.closePath();
        if (fill) ctx.fill();
        if (stroke) ctx.stroke();
      }

      function gameOver(){
        state.gameOver = true;
        state.running = false;
        ui.overlay.classList.add('show');
        const intScore = Math.floor(state.score);
        ui.finalScore.textContent = intScore;
        if (intScore > state.best) {
          state.best = intScore;
          localStorage.setItem('doblo-crash-best', intScore.toString());
          ui.best.textContent = intScore;
        }
      }

      let lastFrame = performance.now();
      function frame(now){
        const dt = Math.min(16.6667, now - lastFrame);
        lastFrame = now;

        fitCanvas();
        layout();

        if (state.running && !state.gameOver) {
          state.time += dt;
          trySpawn(dt);
          update(dt);
        }
        draw();

        requestAnimationFrame(frame);
      }

      requestAnimationFrame(frame);
    })();
  </script>
</body>
</html>
